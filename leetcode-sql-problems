571-hard. Find Median Given Frequency of Numbers
        table: number, frequency
        code:
                WITH median_calculation AS 
                (
                SELECT a.*, ABS(SUM(SIGN(a.Number - b.Number)*b.Frequency)) as median_signal 
                FROM Numbers a, Numbers b 
                GROUP BY a.Number
                )

                SELECT AVG(Number) as median
                FROM median_calculation m
                WHERE m.Frequency >= m.median_signal
        

601-Hard. Human Traffic of Stadium - 
        Task: SELECT the Stadium ativities last more than 3 days that has more than 100 people visits
        Data desription: column name: id(consecutive activity ids), visit_date, people(number of people visits) 

        Method1:
        # when the stadium has more than 100 people visits, check if that day is in a 3 consecutive days that has more than 100 visits.

        SELECT id, visit_date, people FROM stadium a 
        WHERE people >= 100
                 AND (SELECT people FROM stadium b WHERE b.id = a.id + 1) >= 100
                 AND (SELECT people FROM stadium c WHERE c.id = a.id + 2) >= 100 
            OR people >= 100
                 AND (SELECT people FROM stadium e WHERE e.id = a.id - 1) >= 100
                 AND (SELECT people FROM stadium f WHERE f.id = a.id + 1) >= 100
            OR people >= 100
                 AND (SELECT people FROM stadium g WHERE g.id = a.id - 1) >= 100
                 AND (SELECT people FROM stadium h WHERE h.id = a.id - 2) >= 100
        order by id;

        Method2:
        # 1 filter out stadium event with less than 100 people
        # 2 create a new column called consecutive_signal, which deduct row number from each activity id
        # 3 if the activity is consecutive, their consecutive_signal will have the same number
        WITH ranking AS (
        SELECT *, id - ROW_NUMBER() OVER (ORDER BY id ASC) AS consecutive_signal
        FROM Stadium 
        WHERE people >= 100)

        # group by the consecutive_signal, and see if there are more than 3 consecutive days 
        # that the stadium has more than 100 people.
        SELECT id, visit_date, people
        FROM ranking 
        WHERE consecutive_signal IN 
        (SELECT consecutive_signal 
        FROM ranking 
        GROUP BY consecutive_signal
        HAVING COUNT(*) >= 3)

262-Hard. Trips and Users
        task: Write a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between "2013-10-01" and "2013-10-03".
              The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.
              Return the result table in any order. Round Cancellation Rate to two decimal points.
        table: Trips(Id, Client_Id, Driver_Id, City_Id, Status, Request_at) Users( Users_Id, Banned, Role)

        # Filter out UnbannedUser
        With UnbannedUser as (
            SELECT * 
            FROM Users
            WHERE Banned = 'No'
        ),
        # Filter out Trips with unbanned client and driver
            UnbannedTrip as ( 
            SELECT *, SUM(CASE WHEN UnbannedTrip.Status = 'completed' THEN 0 ELSE 1 END) AS 'cancelled',
            COUNT(*) AS 'totalOrder'
            FROM Trips
            WHERE Client_Id IN (SELECT Users_Id FROM UnbannedUser WHERE Role = 'client')
                  AND  Driver_Id IN (SELECT Users_Id FROM UnbannedUser WHERE Role = 'driver' )
            GROUP BY Request_at 
        )

        # Calculate Cancelation Rate by Date

        SELECT DISTINCT Request_at AS 'Day', 
               ROUND(cancelled / totalOrder, 2) AS 'Cancellation Rate'
        FROM UnbannedTrip   
        WHERE Request_at between '2013-10-01' and '2013-10-03'

185-Hard. Department Top Three Salaries

        Method 1：window function
                SELECT Department, Employee, Salary
                FROM 
                (SELECT e.Name as 'Employee', e.Salary, e.DepartmentId, DENSE_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS departmentRank, d.Name AS 'Department'
                 FROM Employee e JOIN Department d ON e.DepartmentId = d.Id) r
                WHERE r.departmentRank <= 3

        Method 2: correlated query/subquery
                SELECT d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
                FROM Employee e1 JOIN Department d ON e1.DepartmentId = d.Id
                WHERE    3 > (SELECT COUNT(DISTINCT e2.Salary)
                         FROM  Employee e2
                         WHERE e2.Salary > e1.Salary AND e1.DepartmentId = e2.DepartmentId);


569. Median Employee Salary
The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary.
        
        #Solution 1: group by + algorithm
        
        SELECT
            Employee.Id, Employee.Company, Employee.Salary
        FROM
            Employee,
            Employee alias
        WHERE
            Employee.Company = alias.Company
        GROUP BY Employee.Company , Employee.Salary
        HAVING SUM(CASE
            WHEN Employee.Salary = alias.Salary THEN 1
            ELSE 0
        END) >= ABS(SUM(SIGN(Employee.Salary - alias.Salary)))  #SIGN(a-b) a-b > 0 return 1, a-b = 0 return 0, a-b < 0 return -1.
        ORDER BY Employee.Id
        ;
        
        
         #Solution 2: temp table + partition by  
         WITH orderedSalary AS (
                SELECT Id, Company, Salary, 
                       row_number() OVER (PARTITION BY Company ORDER BY Salary) AS SalarySeq, 
                       COUNT(*) OVER (Partition by Company) AS empNum
                FROM   Employee)

        SELECT Id, Company, Salary
        FROM orderedSalary
        WHERE SalarySeq IN (ceil(empNum/2), empNum/2 + 1);
        
        
        
627. Swap sex
        UPDATE salary 
           SET sex = CASE sex 
           WHEN 'f' THEN 'm' 
           WHEN 'm' THEN 'f' 
           ELSE 'Default' END 
        WHERE sex IN ('f', 'm')

1270. All People Report to the CEO(within 3 degree of relations)
        SELF JOIN to find report relationships

        WITH relation AS (
        Select employee_id as eId, manager_id as mId
            FROM Employees)

        SELECT r1.eId as employee_id
        FROM relation r1 
             JOIN relation r2 ON r1.mId = r2.eId
             JOIN relation r3 ON r2.mId = r3.eId
             JOIN relation r4 ON r3.mId = r4.eId
        WHERE r1.eId <> 1 AND r4.eId = 1
        
        
626. Exchange Seats OF Students

        SELECT (CASE WHEN MOD(id, 2) = 0 THEN id - 1 
                     WHEN MOD(id, 2) = 1 AND id != totalSeat THEN id + 1
                     ELSE id
                     END) AS id, student
        FROM  seat, (SELECT COUNT(id) totalSeat FROM seat) AS total
        ORDER BY id ASC
        
1179. Reformat Department Table
        the original table has three columns: department Id, month, revenue. My goal is to pivot this table to id as column, month as rows, and revenue as content.
    SELECT id, 
            SUM(CASE when month = "Jan" THEN revenue ELSE null END) AS Jan_Revenue,
            SUM(CASE when month = "Feb" THEN revenue ELSE null END) AS Feb_Revenue,
            SUM(CASE when month = "Mar" THEN revenue ELSE null END) AS Mar_Revenue,
            SUM(CASE when month = "Apr" THEN revenue ELSE null END) AS Apr_Revenue,
            SUM(CASE when month = "May" THEN revenue ELSE null END) AS May_Revenue,
            SUM(CASE when month = "Jun" THEN revenue ELSE null END) AS Jun_Revenue,
            SUM(CASE when month = "Jul" THEN revenue ELSE null END) AS Jul_Revenue,
            SUM(CASE when month = "Aug" THEN revenue ELSE null END) AS Aug_Revenue,
            SUM(CASE when month = "Sep" THEN revenue ELSE null END) AS Sep_Revenue,
            SUM(CASE when month = "Oct" THEN revenue ELSE null END) AS Oct_Revenue,
            SUM(CASE when month = "Nov" THEN revenue ELSE null END) AS Nov_Revenue,
            SUM(CASE when month = "Dec" THEN revenue ELSE null END) AS Dec_Revenue
    FROM Department
    GROUP BY id
    ORDER BY id
    
    
    196. Delete Duplicate Emails
        task: delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.
        data: columns:  Id | Email 
    
        DELETE FROM Person WHERE Id NOT IN 
        (SELECT * FROM(SELECT MIN(Id) FROM Person GROUP BY Email) as p);

1517. Find Users With Valid E-Mails
        task: Write an SQL query to find the users who have valid emails. valid e-mail has a prefix name and a domain where: 
              1.The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.' and/or dash '-'. 
              2.The prefix name must start with a letter.
              3.The domain is '@leetcode.com'.
        table: user_id(int), name(varchar),mail(varchar)
        
        solution:
                # To select the valid email, I need to apply REGEXP
                #   1. domain is @leetcode.com, so use $ denote the end of string: '@leetcode.com$'
                #   2. prefix begin with a letter (lower or upper), then ^ denote the head of string: '^[a-zA-Z]'
                #   3. what beween domain and prefix are 0 or more letters (lower or upper),
                #    digit, underscore, period, dash: [a-zA-Z0-9_.-]*

                SELECT * 
                FROM Users
                WHERE mail REGEXP '^[a-zA-Z][[:alnum:]_.-]*@leetcode\.com$'
                
512. Game Play Analysis（3 problems）
        task 1: Write a SQL query that reports the device that is first logged in for each player.
        data: player_id(int), device_id(int), event_date(date), games_played(int)
        solution:
                SELECT DISTINCT player_id, 
                        FIRST_VALUE(device_id) OVER (PARTITION BY player_id ORDER BY event_date ASC) AS device_id
                FROM Activity

        task 2: Write an SQL query that reports for each player and date, how many games played so far by the player. That is, the total number of games played by the player until that date. Check the example for clarity.
        solution: 
                # obtain the total game played by a time using sum() + Partition By
                select player_id, event_date, sum(games_played) over(partition by player_id order by event_date) as games_played_so_far
                from Activity
                order by player_id
                
        task 3: Write an SQL query that reports the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places.
        
                WITH first_time_login AS
                (
                    SELECT player_id, MIN(event_date) AS first_date
                    FROM Activity
                    GROUP BY player_id
                )

                SELECT ROUND(COUNT(t2.player_id) / COUNT(t1.player_id),2) AS returned_player_fraction
                FROM firstDate  t1 LEFT JOIN Activity t2  ON t1.player_id = t2.player_id AND t1.first_date = t2.event_date - 1
                
570. Managers with at Least 5 Direct Reports
        task:  write a SQL query that finds out managers with at least 5 direct report. For the above table, your SQL query should return
        code:  SELECT Name
               FROM Employee a
               WHERE Id IN (SELECT ManagerId FROM Employee b GROUP BY ManagerId HAVING COUNT(*) >= 5 )
               
574. Winning Candidate
        task:  to find the name of the winning candidate
        code:
                SELECT Name
                FROM Candidate
                WHERE id = (SELECT CandidateId FROM Vote GROUP BY CandidateId ORDER BY COUNT(*) DESC LIMIT 1)        
                
                

